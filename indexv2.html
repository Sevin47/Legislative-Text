<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WV Smart Route Builder v64 (Context Search)</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    
    <style>
        :root { --wv-gold: #E2A600; --wv-blue: #002855; --bg-gray: #f4f4f9; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: var(--bg-gray); margin: 0; padding: 20px; display: flex; flex-direction: column; align-items: center; }
        .container { background: white; width: 95%; max-width: 1200px; padding: 30px; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
        h1 { color: var(--wv-blue); border-bottom: 3px solid var(--wv-gold); padding-bottom: 10px; margin-top: 0; }
        
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 25px; }
        textarea { width: 100%; height: 120px; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-family: monospace; resize: vertical; }
        
        button { background-color: var(--wv-blue); color: white; border: none; padding: 12px 24px; font-size: 16px; border-radius: 4px; cursor: pointer; margin-top: 10px; transition: background 0.2s; }
        button:hover { background-color: #004080; }
        
        .result-box { background: #eef; padding: 20px; border-radius: 4px; border-left: 5px solid var(--wv-blue); }
        .measure-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px; background: #fff; padding: 10px; border: 1px solid #ddd; }
        .measure-box { display: flex; flex-direction: column; }
        .measure-box label { font-size: 0.85em; font-weight: bold; color: #555; }
        .measure-box input { padding: 5px; font-family: monospace; border: 1px solid #ccc; font-weight: bold; color: #002855; }
        
        .config-panel { background: #fff3cd; padding: 10px; border-radius: 4px; border: 1px solid #ffeeba; margin-bottom: 10px; font-size: 0.85em; }
        .code-display { font-family: monospace; font-size: 1.4em; letter-spacing: 1px; background: #333; color: #0f0; padding: 10px; border-radius: 4px; margin-top: 10px; display: inline-block; width: 100%; text-align: center; box-sizing: border-box;}
        
        .status { font-weight: bold; margin-top: 10px; }
        .success { color: green; }
        .error { color: #d9534f; }
        .warning { color: #f0ad4e; }

        #debugConsole {
            width: 100%; height: 250px; background: #000; color: #0f0; 
            font-family: monospace; padding: 10px; margin-top: 20px; 
            overflow-y: auto; font-size: 0.85em; border-radius: 4px; border: 2px solid #444;
        }
        
        /* MAP STYLES */
        #map { height: 400px; width: 100%; margin-top: 20px; border-radius: 8px; border: 2px solid #ccc; z-index: 1; }
        
        table { width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 14px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: var(--wv-blue); color: white; }
    </style>
    
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
</head>
<body>

<div class="container">
    <h1>WV Smart Route Builder v64 (Context Search)</h1>
    <p>Stable Logic (v51) + Cyan Map + Esri Place Geocoding for contextual start/end points.</p>
    
    <div class="grid">
        <div>
            <h3>1. Resolution Text</h3>
            <textarea id="inputText" placeholder="Paste resolution text here...&#10;Example: 'Name State Route 80, beginning in Iaeger and ending in Bradshaw'"></textarea>
            <button onclick="runCompleteAnalysis()">Analyze & Map</button>
            
            <div style="margin-top: 25px;">
                <h3>3. Smart Measure Extraction</h3>
                <div class="measure-grid">
                    <div class="measure-box">
                        <label>Begin Milepoint</label>
                        <input type="text" id="beginMile" placeholder="0.000">
                    </div>
                    <div class="measure-box">
                        <label>End Milepoint</label>
                        <input type="text" id="endMile" placeholder="0.000">
                    </div>
                </div>
                <div id="measureLogicOutput" style="font-size: 0.9em; margin-top: 8px; color: #666; font-style: italic;">
                    Waiting for analysis...
                </div>
            </div>
        </div>
        
        <div>
            <h3>2. Configuration & Results</h3>
            
            <div class="config-panel">
                <strong>Service Configuration</strong><br>
                <em>Primary:</em> WVDOT SAMS (Layer 118)<br>
                <em>Context:</em> Esri World Geocoder
            </div>

            <div id="resultArea" class="result-box" style="display:none;">
                <table id="compTable"></table>
                
                <div style="margin-top: 15px;">
                    <strong>Generated Route ID:</strong><br>
                    <span id="finalRouteID" class="code-display">WAITING...</span>
                </div>

                <div id="gisCheck" style="margin-top: 15px; border-top: 1px solid #ccc; padding-top: 10px;">
                    <strong>LRS Verification (Layer 89):</strong><br>
                    <span id="lrsStatus">Pending...</span>
                    <div id="dbMatchBox"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="map"></div>

    <div id="debugConsole">System Ready...</div>
</div>

<script>
    // --- CONFIGURATION ---
    const LRS_LAYER_URL = "https://gis.transportation.wv.gov/arcgis/rest/services/Roads_And_Highways/Publication_LRS/FeatureServer/89";
    const SAMS_LAYER_URL = "https://gis.transportation.wv.gov/arcgis/rest/services/Roads_And_Highways/Publication_LRS/FeatureServer/118";
    const ESRI_GEOCODE_URL = "https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/findAddressCandidates"; // V64: Esri Geocoder

    // --- MAP VARS ---
    let map, routeLayer, segmentLayer, markersLayer;

    // --- DATABASE ---
    const COUNTY_CODES = { "BARBOUR":"01", "BERKELEY":"02", "BOONE":"03", "BRAXTON":"04", "BROOKE":"05", "CABELL":"06", "CALHOUN":"07", "CLAY":"08", "DODDRIDGE":"09", "FAYETTE":"10", "GILMER":"11", "GRANT":"12", "GREENBRIER":"13", "HAMPSHIRE":"14", "HANCOCK":"15", "HARDY":"16", "HARRISON":"17", "JACKSON":"18", "JEFFERSON":"19", "KANAWHA":"20", "LEWIS":"21", "LINCOLN":"22", "LOGAN":"23", "MCDOWELL":"24", "MARION":"25", "MARSHALL":"26", "MASON":"27", "MERCER":"28", "MINERAL":"29", "MINGO":"30", "MONONGALIA":"31", "MONROE":"32", "MORGAN":"33", "NICHOLAS":"34", "OHIO":"35", "PENDLETON":"36", "PLEASANTS":"37", "POCAHONTAS":"38", "PRESTON":"39", "PUTNAM":"40", "RALEIGH":"41", "RANDOLPH":"42", "RITCHIE":"43", "ROANE":"44", "SUMMERS":"45", "TAYLOR":"46", "TUCKER":"47", "TYLER":"48", "UPSHUR":"49", "WAYNE":"50", "WEBSTER":"51", "WETZEL":"52", "WIRT":"53", "WOOD":"54", "WYOMING":"55" };
    const WV_TOWNS = { "PRINCETON": "MERCER", "BLUEFIELD": "MERCER", "KEYSER": "MINERAL", "PIEDMONT": "MINERAL", "ELK GARDEN": "MINERAL", "CHARLESTON": "KANAWHA", "HUNTINGTON": "CABELL", "MORGANTOWN": "MONONGALIA", "PARKERSBURG": "WOOD", "WHEELING": "OHIO", "BECKLEY": "RALEIGH", "FAIRMONT": "MARION", "CLARKSBURG": "HARRISON", "MARTINSBURG": "BERKELEY", "WEIRTON": "HANCOCK", "ELKINS": "RANDOLPH", "BUCKHANNON": "UPSHUR", "LEWISBURG": "GREENBRIER", "SUMMERSVILLE": "NICHOLAS", "OAK HILL": "FAYETTE", "POINT PLEASANT": "MASON", "RIPLEY": "JACKSON", "CHAPMANVILLE": "LOGAN", "LOGAN": "LOGAN", "MAN": "LOGAN", "WILLIAMSON": "MINGO", "WELCH": "MCDOWELL", "HINTON": "SUMMERS", "SUTTON": "BRAXTON", "CLAY": "CLAY", "SPENCER": "ROANE", "NEW MARTINSVILLE": "WETZEL" };

    // --- MAP INIT ---
    function initMap() {
        if(map) return;
        map = L.map('map').setView([38.3498, -81.6326], 7);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap contributors' }).addTo(map);
        routeLayer = L.layerGroup().addTo(map);
        segmentLayer = L.layerGroup().addTo(map);
        markersLayer = L.layerGroup().addTo(map);
    }

    function log(msg, type='info') {
        const c = document.getElementById('debugConsole');
        const time = new Date().toLocaleTimeString();
        const color = type === 'error' ? '#ff4444' : type === 'success' ? '#00ff00' : type === 'warning' ? '#ffaa00' : '#cccccc';
        c.innerHTML += `<div style="color:${color}">[${time}] ${msg}</div>`;
        c.scrollTop = c.scrollHeight;
    }

    // --- GEOMETRY HELPERS FOR MAPPING ---
    function getMeasure(pt) { 
        if (Array.isArray(pt)) {
            if (pt.length === 3) return pt[2];
            if (pt.length === 4) return pt[3];
        }
        return null;
    }

    async function executeLayerQuery(url, params) {
        const formData = new URLSearchParams();
        formData.append('f', 'json');
        for (const key in params) {
            const val = typeof params[key] === 'object' ? JSON.stringify(params[key]) : params[key];
            formData.append(key, val);
        }
        try {
            const resp = await fetch(url + "/query", { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body: formData });
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            const data = await resp.json();
            if (data.error) throw new Error(`GIS Error: ${data.error.message}`);
            return data;
        } catch (e) { throw e; }
    }

    // V64: Esri Geocoder Helper
    async function geocodePlace(placeName) {
        const queryStr = new URLSearchParams({
            f: 'json',
            SingleLine: `${placeName}, WV`,
            outFields: 'City,County,Type',
            maxLocations: 1,
            // WV Extent roughly: xmin: -9199945, ymin: 4467222, xmax: -8651646, ymax: 4959210 (Web Mercator)
            // Or Lat/Long: -82.64, 37.20, -77.71, 40.63
            searchExtent: '-82.64,37.20,-77.71,40.63'
        }).toString();

        try {
            const resp = await fetch(`${ESRI_GEOCODE_URL}?${queryStr}`);
            const data = await resp.json();
            if (data.candidates && data.candidates.length > 0) {
                return data.candidates[0].location; // {x: long, y: lat}
            }
            return null;
        } catch (e) { return null; }
    }

    async function runCompleteAnalysis() {
        const text = document.getElementById('inputText').value;
        const resultDiv = document.getElementById('resultArea');
        const lrsStatus = document.getElementById('lrsStatus');
        const dbBox = document.getElementById('dbMatchBox');
        
        resultDiv.style.display = 'block';
        lrsStatus.innerHTML = '<span class="warning">Querying GIS...</span>';
        dbBox.innerHTML = '';
        document.getElementById('measureLogicOutput').innerHTML = 'Analyzing...';
        document.getElementById('beginMile').value = '';
        document.getElementById('endMile').value = '';
        
        document.getElementById('debugConsole').innerHTML = "<div>Starting New Analysis...</div>";
        
        initMap();
        routeLayer.clearLayers();
        segmentLayer.clearLayers();
        markersLayer.clearLayers();

        const context = analyzeContext(text);
        renderTable(context);
        
        if (!context.countyCode) {
            lrsStatus.innerHTML = `<span class="error">✘ COUNTY UNKNOWN</span>`;
            log("Error: Could not determine County Code.", 'error');
            return;
        }

        if (context.candidates.length === 0) {
            log("No identifiable route found.", 'error');
            return;
        }

        const subject = context.candidates[0]; // Winner
        let stem = null;

        if (subject.type === "NAME") {
            log(`Winner: "${subject.label}" (Score: ${subject.score})`);
            log(`Resolving Route ID for "${subject.label}"...`);
            const nameResult = await resolveRouteByDualSearch(subject.label, context.countyCode);
            if (nameResult) {
                stem = nameResult.stem;
                log(`Road Name Resolved to Route ID: ${stem}`, 'success');
                subject.resolvedId = stem;
            } else {
                log(`Resolution failed for: ${subject.label}`, 'error');
                return;
            }
        } else {
            stem = `${context.countyCode}${subject.ssCode}${subject.num.padStart(4,'0')}0000`;
            log(`Winner: ${subject.label} (Score: ${subject.score})`);
            
            let verified = await verifyLrsId(stem);
            if (!verified && subject.ssName.includes("Generic")) {
                log(`State Route failed. Trying County Route...`, 'warning');
                const countyStem = `${context.countyCode}4${subject.num.padStart(4,'0')}0000`;
                verified = await verifyLrsId(countyStem);
                if (verified) {
                    stem = countyStem;
                    log(`✔ County Route Confirmed: ${stem}`, 'success');
                } else {
                    log(`County Route failed. Trying US Route...`, 'warning');
                    const usStem = `${context.countyCode}2${subject.num.padStart(4,'0')}0000`;
                    verified = await verifyLrsId(usStem);
                    if (verified) {
                        stem = usStem;
                        log(`✔ US Route Confirmed: ${stem}`, 'success');
                    }
                }
            } else if (verified) {
                log(`✔ Route Confirmed: ${stem}`, 'success');
            }
            
            if(!verified) {
                log(`❌ Primary Route ${stem} not found in GIS.`, 'error');
                lrsStatus.innerHTML = `<span class="error">✘ ROUTE NOT FOUND</span>`;
                return;
            }
        }

        document.getElementById('finalRouteID').textContent = `${stem}??`;
        
        let intersectCandidates = context.candidates.filter(c => c !== subject);
        
        // V64: Pass parsed location context to engine
        await verifyAndMeasure(stem, context, text, intersectCandidates);
    }

    async function verifyLrsId(routeId) {
        try {
            const stem = routeId.substring(0,11);
            const data = await executeLayerQuery(LRS_LAYER_URL, {
                where: `CO_ROUTEID LIKE '${stem}%'`,
                outFields: 'CO_ROUTEID',
                returnGeometry: false
            });
            return (data.features && data.features.length > 0) ? true : false;
        } catch(e) { return false; }
    }

    async function resolveRouteByDualSearch(name, countyCode) {
        const suffixes = ["ROAD","RD","DRIVE","DR","STREET","ST","AVENUE","AVE","BOULEVARD","BLVD","LANE","LN","WAY","PIKE","HIGHWAY","HWY"];
        const upperName = name.toUpperCase();
        let coreName = upperName;
        suffixes.forEach(s => { if(coreName.endsWith(" " + s)) coreName = coreName.slice(0, -(s.length + 1)).trim(); });
        
        log(`Searching SAMS (Layer 118) for "${coreName}"...`);
        try {
            const samsData = await executeLayerQuery(SAMS_LAYER_URL, {
                where: `UPPER(STREET_NAME) LIKE '%${coreName}%'`,
                outFields: 'ROUTE_ID,STREET_NAME',
                returnGeometry: true,
                outSR: 4326 
            });

            if (samsData.features && samsData.features.length > 0) {
                const candidates = samsData.features
                    .filter(f => f.attributes.ROUTE_ID && f.attributes.ROUTE_ID.toString().startsWith(countyCode))
                    .map(f => {
                        const id = f.attributes.ROUTE_ID;
                        const sName = f.attributes.STREET_NAME.toUpperCase();
                        let length = 0;
                        if (f.geometry.paths) {
                            f.geometry.paths.forEach(path => {
                                for(let i=0; i<path.length-1; i++) {
                                    length += Math.sqrt(Math.pow(path[i+1][0]-path[i][0], 2) + Math.pow(path[i+1][1]-path[i][1], 2));
                                }
                            });
                        }
                        let score = 0;
                        if (sName === upperName || sName === (coreName + " RD") || sName === (coreName + " ROAD")) score = 100;
                        else if (sName.startsWith(coreName)) score = 50;
                        else score = 10;
                        return { id: id, name: f.attributes.STREET_NAME, score: score, length: length, geom: f.geometry };
                    });

                if (candidates.length > 0) {
                    candidates.sort((a,b) => {
                        if (b.score !== a.score) return b.score - a.score;
                        return b.length - a.length; 
                    });
                    const winner = candidates[0];
                    log(`Winner (Longest): ${winner.name} (${winner.id})`, 'success');
                    if (await verifyLrsId(winner.id)) return { stem: winner.id.substring(0,11) + "00", label: winner.name };
                    return null; // intersection search skipped for brevity here
                }
            }
        } catch (e) { log(`SAMS Search Error: ${e.message}`, 'warning'); }
        return null;
    }

    function analyzeContext(text) {
        const clean = text.replace(/\s+/g, ' ').toUpperCase();
        let countyName=null, countyCode=null;
        for (const [name, code] of Object.entries(COUNTY_CODES)) { if (clean.includes(name + " COUNTY")) { countyName = name; countyCode = code; break; } }
        if (!countyCode) { for (const [town, mappedCounty] of Object.entries(WV_TOWNS)) { if (new RegExp(`\\b${town}\\b`).test(clean)) { countyName = mappedCounty; countyCode = COUNTY_CODES[mappedCounty]; break; } } }

        let candidates = [];
        let places = []; // V64: Extracted places

        const quotedRegex = /["“”](.*?)["“”]/g;
        let quotedNames = [];
        let match;
        while ((match = quotedRegex.exec(text)) !== null) { quotedNames.push(match[1].toUpperCase()); }

        // Place Context Extraction (e.g. "in Iaeger", "ending at Bradshaw")
        const placeRegex = /(?:in|at)\s+([A-Z][a-zA-Z\.\s]+?)(?:\s+and|,|\.|$)/g;
        let pMatch;
        while ((pMatch = placeRegex.exec(text)) !== null) {
            let pName = pMatch[1].trim();
            // Filter out obvious noise (county names, states, common words)
            if (!pName.toUpperCase().includes("COUNTY") && pName.toUpperCase() !== "WEST VIRGINIA" && pName.toUpperCase() !== "WV") {
                places.push(pName);
            }
        }

        const routeRegex = /(?:(U\.?\s*S\.?|United\s+States|State|WV|West\s+Virginia|County|CR|CO|I-|Interstate)\s+)?(?:Route|Hwy|Road|Highway)\s*(\d+)/gi;
        const matches = [...text.matchAll(routeRegex)];
        for (const m of matches) {
            const fullMatch = m[0]; const prefix = m[1] ? m[1].toUpperCase().replace(/\s/g, '') : ""; const num = m[2]; 
            const index = m.index;
            const preText = text.substring(Math.max(0, index - 60), index).toLowerCase();
            
            let score = 0;
            if (/name|designate|dedicate|portion of|section of|stretch of|road on/.test(preText)) score += 100;
            const immediatePre = text.substring(Math.max(0, index - 15), index).toLowerCase();
            if (/at\s*$|from\s*$|with\s*$|and\s*$|between\s*$/.test(immediatePre)) score -= 500;
            else if (/intersection|junction|beginning|ending/.test(preText)) score -= 50;
            
            let ssCode = '4'; let ssName = 'County';
            if (prefix.includes("COUNTY") || prefix === "CR" || prefix === "CO") { ssCode = '4'; ssName = "County"; }
            else if (prefix.includes("U.S") || prefix === "US") { ssCode = '2'; ssName = "US"; }
            else if (prefix.includes("INTERSTATE") || prefix === "I-") { ssCode = '1'; ssName = "Interstate"; }
            else if (prefix.includes("STATE") || prefix.includes("WV") || prefix.includes("VIRGINIA")) { ssCode = '3'; ssName = "State"; }
            else { ssCode = '3'; ssName = "State (Generic)"; } 
            candidates.push({ type: "NUMBER", num, ssCode, ssName, label: fullMatch, score });
        }

        const nameRegex = /([A-Z][a-zA-Z\.]+(?:\s+[A-Z][a-zA-Z\.]+)*\s+(?:Road|Rd|Drive|Dr|Street|St|Avenue|Ave|Boulevard|Blvd|Pike|Highway|Hwy))/g;
        const nameMatches = [...text.matchAll(nameRegex)];
        for (const nm of nameMatches) {
            const name = nm[1];
            if (quotedNames.some(q => q.includes(name.toUpperCase()))) continue;
            if (!name.toUpperCase().startsWith("COUNTY") && !name.toUpperCase().startsWith("STATE") && !name.toUpperCase().startsWith("WEST")) {
                const index = nm.index;
                const preText = text.substring(Math.max(0, index - 60), index).toLowerCase();
                let score = 0;
                if (/name|designate|dedicate|portion of|section of|stretch of|road on/.test(preText)) score += 100;
                const immediatePre = text.substring(Math.max(0, index - 15), index).toLowerCase();
                if (/at\s*$|from\s*$|with\s*$|and\s*$|between\s*$/.test(immediatePre)) score -= 500;
                else if (/intersection|junction|beginning|ending/.test(preText)) score -= 50;
                candidates.push({ type: "NAME", label: name, score });
            }
        }

        candidates.sort((a,b) => b.score - a.score);
        return { countyName, countyCode, candidates, places };
    }

    async function verifyAndMeasure(searchStem, context, originalText, intersectCandidates) {
        const statusBox = document.getElementById('lrsStatus');
        const dbBox = document.getElementById('dbMatchBox');
        let validRouteId = null;
        let routeFeatures = null;

        log(`Querying LRS for Primary Route...`);
        try {
            const data = await executeLayerQuery(LRS_LAYER_URL, {
                where: `CO_ROUTEID LIKE '${searchStem}%'`,
                outFields: 'CO_ROUTEID,CO_RouteLabel',
                returnGeometry: true, returnM: true, 
                outSR: 4326 
            });

            if (data.features && data.features.length > 0) {
                data.features.sort((a, b) => {
                    const idA = a.attributes.CO_ROUTEID; const idB = b.attributes.CO_ROUTEID;
                    return (idB.slice(-2)==='00'?3:1) - (idA.slice(-2)==='00'?3:1);
                });
                const feat = data.features[0]; 
                validRouteId = feat.attributes.CO_ROUTEID; 
                routeFeatures = [feat]; 

                statusBox.innerHTML = `<span class="success">✔ VALIDATED</span>`;
                dbBox.innerHTML = `<div class="success">Primary: ${validRouteId}<br>Label: ${feat.attributes.CO_RouteLabel}</div>`;
                document.getElementById('finalRouteID').textContent = validRouteId;
                log(`Locked Primary Route: ${validRouteId}`, 'success');
                
                drawRouteOnMap(feat.geometry);
                
                await runDetectionLogic(originalText, routeFeatures, validRouteId, context, intersectCandidates);
            } else {
                statusBox.innerHTML = `<span class="error">✘ ROUTE NOT FOUND</span>`;
                log("Primary Route not found in GIS.", 'error');
            }
        } catch (err) { log(`Critical Error: ${err.message}`, 'error'); }
    }

    async function runDetectionLogic(text, routeFeatures, mainRouteId, context, otherRoutes) {
        const logicOut = document.getElementById('measureLogicOutput');
        const beginInput = document.getElementById('beginMile');
        const endInput = document.getElementById('endMile');
        const sanitize = (num) => Math.max(0, num).toFixed(3);
        
        let gMin = 99999, gMax = -99999;
        const mainFeat = routeFeatures[0];
        if (mainFeat.geometry && mainFeat.geometry.paths) {
            mainFeat.geometry.paths.forEach(p => p.forEach(pt => {
                let m = getMeasure(pt);
                if (m !== null) { if (m < gMin) gMin = m; if (m > gMax) gMax = m; }
            }));
        }
        log(`Global Extents: ${sanitize(gMin)} - ${sanitize(gMax)}`);

        const lower = text.toLowerCase();
        let candidates = [];

        // 1. TEXT EXTRACTION (PRIORITY 1)
        const mpRegex = /(?:mile\s*(?:post|point|marker)|mp|m\.p\.)\s*(\d+(?:\.\d+)?)/gi;
        const textMatches = [...lower.matchAll(mpRegex)].map(m => parseFloat(m[1]));
        if (textMatches.length > 0) {
            textMatches.sort((a,b) => a-b);
            let tMin = textMatches[0];
            let tMax = textMatches.length > 1 ? textMatches[textMatches.length-1] : tMin;
            beginInput.value = tMin.toFixed(3);
            endInput.value = tMax.toFixed(3);
            logicOut.innerHTML = `<span class='success'>✔ Found Explicit Text Measures.</span>`;
            visualizeSegment(mainFeat.geometry, tMin, tMax);
            return;
        }

        // 2. INTERSECTIONS (PRIORITY 2)
        if (otherRoutes.length > 0) {
            log("Checking intersections...", 'warning');
            let ranges = [];
            for (const other of otherRoutes) {
                let stemsToTry = [];
                if (other.type === "NAME") {
                    log(`Resolving intersection with Name: ${other.label}`);
                    const nameRes = await resolveRouteByDualSearch(other.label, context.countyCode);
                    if (nameRes) stemsToTry.push(nameRes.stem);
                } else {
                    const build = (type) => `${context.countyCode}${type}${other.num.padStart(4,'0')}0000`;
                    stemsToTry.push(build(other.ssCode)); 
                    if (other.ssName.includes("Generic")) { stemsToTry.push(build('3')); stemsToTry.push(build('4')); stemsToTry.push(build('2')); }
                }

                for (const stem of [...new Set(stemsToTry)]) {
                    const range = await calculateIntersectionRange(routeFeatures, stem);
                    if (range) {
                        log(`--> Intersection Range: ${range.min.toFixed(3)} - ${range.max.toFixed(3)}`, 'success');
                        ranges.push(range);
                        break; 
                    }
                }
            }
            if (ranges.length >= 2) {
                ranges.sort((a,b) => a.center - b.center);
                let startM = ranges[0].max; let endM = ranges[ranges.length-1].min;     
                if (startM > endM) { startM = ranges[0].min; endM = ranges[ranges.length-1].max; }
                candidates.push({min: startM, max: endM, source:"Trimmed Intersections", priority: 20});
            } 
        }

        // 3. V64: CONTEXT PLACES (PRIORITY 3)
        if (candidates.length === 0 && context.places && context.places.length > 0) {
            log(`Found Context Places: ${context.places.join(", ")}`, 'warning');
            let placeHits = [];
            
            for (const place of context.places) {
                const loc = await geocodePlace(place);
                if (loc) {
                    log(`--> Geocoded ${place} to ${loc.y.toFixed(4)}, ${loc.x.toFixed(4)}`);
                    // Snap to route
                    const m = snapCoordinateToMeasure(mainFeat.geometry, loc);
                    if (m !== null) {
                        log(`--> Snapped ${place} to MP ${m.toFixed(3)}`, 'success');
                        placeHits.push(m);
                    }
                }
            }

            if (placeHits.length >= 2) {
                placeHits.sort((a,b) => a-b);
                candidates.push({min: placeHits[0], max: placeHits[placeHits.length-1], source:"Context Geocoding", priority: 15});
            } else if (placeHits.length === 1) {
                // If only 1 place found, assume it's start or end based on global
                const p = placeHits[0];
                const dToStart = Math.abs(p - gMin);
                const dToEnd = Math.abs(p - gMax);
                if (dToStart < dToEnd) {
                     candidates.push({min: p, max: gMax, source:"Context Anchor (Start)", priority: 10});
                } else {
                     candidates.push({min: gMin, max: p, source:"Context Anchor (End)", priority: 10});
                }
            }
        }

        candidates.sort((a,b) => b.priority - a.priority);
        if (candidates.length > 0) {
            const winner = candidates[0];
            beginInput.value = winner.min.toFixed(3);
            endInput.value = winner.max.toFixed(3);
            logicOut.innerHTML = `<span class='success'>✔ Found Measures via ${winner.source}.</span>`;
            visualizeSegment(mainFeat.geometry, winner.min, winner.max);
            return;
        }
        
        beginInput.value = sanitize(gMin);
        endInput.value = sanitize(gMax);
        logicOut.innerHTML = `<span class='success'>✔ 'Whole Route' inferred (00 - End).</span>`;
        visualizeSegment(mainFeat.geometry, gMin, gMax);
    }

    async function calculateIntersectionRange(mainFeatures, otherStem) {
        try {
            const data = await executeLayerQuery(LRS_LAYER_URL, {
                where: `CO_ROUTEID LIKE '${otherStem}%'`,
                returnGeometry: true, returnM: false, outSR: 4326 
            });
            if (!data.features || data.features.length===0) return null;
            const mainPaths = mainFeatures[0].geometry.paths;
            let hits = [];
            for (const feat of data.features) {
                const otherPaths = feat.geometry.paths;
                for (const mPath of mainPaths) {
                    for (const mPt of mPath) {
                        const mx = mPt[0], my = mPt[1], mm = getMeasure(mPt); 
                        if (mm === null) continue;
                        for (const oPath of otherPaths) {
                            for (const oPt of oPath) {
                                const dist = Math.sqrt(Math.pow(mx-oPt[0], 2) + Math.pow(my-oPt[1], 2));
                                if (dist < 0.0005) hits.push(mm); 
                            }
                        }
                    }
                }
            }
            if (hits.length === 0) return null;
            hits.sort((a,b) => a-b);
            return { min: hits[0], max: hits[hits.length-1], center: (hits[0]+hits[hits.length-1])/2 };
        } catch(e) { return null; }
    }

    // V64: SNAP COORD TO MEASURE
    function snapCoordinateToMeasure(geometry, loc) {
        const targetX = loc.x; // Long
        const targetY = loc.y; // Lat
        let bestM = null;
        let minDist = 999999;

        geometry.paths.forEach(path => {
            for (let i = 0; i < path.length; i++) {
                const ptX = path[i][0];
                const ptY = path[i][1];
                const ptM = getMeasure(path[i]);
                
                if (ptM !== null) {
                    const dist = Math.sqrt(Math.pow(ptX - targetX, 2) + Math.pow(ptY - targetY, 2));
                    if (dist < minDist) {
                        minDist = dist;
                        bestM = ptM;
                    }
                }
            }
        });
        
        // Return null if it's too far away (> ~5km)
        if (minDist > 0.05) return null; 
        return bestM;
    }

    function renderTable(context) {
        const table = document.getElementById('compTable');
        const primary = context.candidates && context.candidates.length > 0 ? context.candidates[0] : { label: "None", num: "-" };
        let countyHtml = `<td>${context.countyName || "Not Found"}</td><td>${context.countyCode || "ERR"}</td>`;
        table.innerHTML = `<tr><th>Field</th><th>Value</th><th>Code</th></tr><tr><td>County</td>${countyHtml}</tr><tr><td>Sign System</td><td>${primary.ssName || "Auto"}</td><td>${primary.ssCode || "?"}</td></tr><tr><td>Route Num</td><td>${primary.label || "-"}</td><td>${primary.num || "-"}</td></tr>`;
    }

    // --- MAP VISUALIZATION ---
    function drawRouteOnMap(geometry) {
        const latlngs = [];
        geometry.paths.forEach(path => {
            const pathArr = [];
            path.forEach(pt => pathArr.push([pt[1], pt[0]])); 
            latlngs.push(pathArr);
        });
        
        L.polyline(latlngs, {color: '#0079c1', weight: 4, opacity: 0.5}).addTo(routeLayer);
        const poly = L.polyline(latlngs);
        map.fitBounds(poly.getBounds(), {padding: [50,50]});
    }

    function visualizeSegment(geometry, bmp, emp) {
        segmentLayer.clearLayers();
        markersLayer.clearLayers();
        
        const startCoord = getCoordAtMeasure(geometry, bmp);
        const endCoord = getCoordAtMeasure(geometry, emp);

        if (startCoord) {
            L.marker([startCoord.y, startCoord.x]).addTo(markersLayer)
             .bindPopup(`<b>Start</b><br>BMP: ${bmp.toFixed(3)}`).openPopup();
        }
        if (endCoord) {
            L.marker([endCoord.y, endCoord.x]).addTo(markersLayer)
             .bindPopup(`<b>End</b><br>EMP: ${emp.toFixed(3)}`);
        }

        const segmentLatlngs = extractSegmentPath(geometry, bmp, emp);
        if (segmentLatlngs.length > 0) {
            L.polyline(segmentLatlngs, {color: '#00ffff', weight: 8, opacity: 0.9}).addTo(segmentLayer);
        } else if (startCoord && endCoord) {
            L.polyline([ [startCoord.y, startCoord.x], [endCoord.y, endCoord.x] ], {color: '#00ffff', weight: 8, opacity: 0.9}).addTo(segmentLayer);
        }
    }

    function extractSegmentPath(geometry, minM, maxM) {
        const trueMin = Math.min(minM, maxM);
        const trueMax = Math.max(minM, maxM);
        const segmentPaths = [];

        geometry.paths.forEach(path => {
            let currentSeg = [];
            let isTracking = false;

            for (let i = 0; i < path.length; i++) {
                const pt = path[i];
                const m = getMeasure(pt);
                if (m === null) continue;

                if (m >= trueMin && m <= trueMax) {
                    if (!isTracking) isTracking = true;
                    currentSeg.push([pt[1], pt[0]]); 
                } else if (isTracking) {
                    isTracking = false;
                    segmentPaths.push(currentSeg);
                    currentSeg = [];
                }
            }
            if (currentSeg.length > 0) segmentPaths.push(currentSeg);
        });
        return segmentPaths;
    }

    function getCoordAtMeasure(geometry, targetM) {
        let bestPt = null;
        let minDiff = 99999;
        for (const path of geometry.paths) {
            for (let i = 0; i < path.length; i++) {
                const pt = path[i];
                const m = getMeasure(pt);
                if (m !== null) {
                    const diff = Math.abs(m - targetM);
                    if (diff < minDiff) {
                        minDiff = diff;
                        bestPt = { x: pt[0], y: pt[1] };
                    }
                }
            }
        }
        return bestPt; 
    }
</script>

</body>
</html>
